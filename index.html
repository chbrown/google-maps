<!DOCTYPE html>
<meta charset="utf-8">
<title>Google Maps Layers</title>
<style type="text/css">
html {
  height: 100%;
}
body {
  font-family: "Helvetica Neue", Helvetica, Arial;
  font-weight: 200;

  height: 100%;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
h1, h2, h3, h4, h5, h6 {
  margin: 0.25em 0 0.5em;
}
p {
  margin: 0.5em 0;
}
#map {
  height: 100%;
}
.map-container {
  margin: 10px;
  border: 1px solid #bbb;
  background-color: #ddd;
  height: 70%;
}
.control {
  margin: 10px;
  float: left;
}
table {
  border-collapse: collapse;
}
td {
  padding: 0 8px 2px 0;
  vertical-align: top;
  font-size: 90%;
  white-space: nowrap;
}
table.features tr {
  cursor: normal;
}
table.features tr td {
  padding: 2px 8px 2px 0;
}
label span {
  font-weight: bold;
}
</style>

<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCDYwRP0wOSFFgzJDr73JtketDW335C234&sensor=true"></script>
<script src="lib/underscore.min.js"></script>
<script src="lib/jquery.min.js"></script>
<script src="lib/backbone.min.js"></script>
<script src="google-maps.js"></script>
<script>
var down = (new KeyState()).down;

// Backbone.sync = function(method, model, options) {};

// All GeoJSON is (lon, lat), opposite of Google.

var Feature = Backbone.Model.extend({
  // has fields: type, geometry, properties
  toJSON: function() {
    return _.extend({type: "feature"}, this.attributes);
  },
  toString: function() {
    return this.get('geometry').toString();
  },
  parse: function(response, options) {
    // have to type-boost to get a versatile Backbone model
    response.geometry = new Geometries[response.geometry.type](response.geometry);
    return response;
  }
});

var FeatureView = Backbone.View.extend({
  tagName: 'tr',
  templateString: '<td><%= type %></td>\
    <td><%= coordinates %></td>\
    <td><%= label %></td>',
  initialize: function(opts) {
    this.map = opts.map;
    this.render();
  },
  render: function() {
    var properties = this.model.get('properties') || {};
    var html = _.template(this.templateString, {
      type: this.model.get('geometry').get('type'),
      coordinates: this.model.toString(),
      label: properties.label
    });
    this.$el.append(html);
    this.shape = this.model.get('geometry').googleShape(this.map);
  },
  events: {
    'mouseover': function(ev) {
      this.model.get('geometry').get('type');
      // center always returns a lon,lat pair.
    },
    'click': function(ev) {
      if (down[16]) { // shift-down
        this.model.collection.remove(this.model);
        this.remove();
      }
      else {
        this.model.get('geometry').focus(this.map);
      }
    }
  }
});

var FeatureCollection = Backbone.Collection.extend({
  model: Feature,
  initialize: function(opts) {
    if (localStorage.features) {
      this.reset(JSON.parse(localStorage.features), {parse: true});
    }

    this.on('add remove reset', this.persist, this);
  },
  persist: function() {
    localStorage.features = JSON.stringify(this.toJSON());
  }
});

var Polygon = Backbone.Model.extend({
  // fields: type, coordinates
  initialize: function(opts) {
    this.set('type', 'Polygon');
  },
  toString: function() {
    var longitudes_latitudes = _.zip.apply(null, this.get('coordinates'));
    return [
      _.min(longitudes_latitudes[0]).toFixed(4),
      _.min(longitudes_latitudes[1]).toFixed(4),
      _.max(longitudes_latitudes[0]).toFixed(4),
      _.max(longitudes_latitudes[1]).toFixed(4)
    ].join(',');
  },
  focus: function(map) {
    map.fitBounds(this.googleShape().getBounds());
  },
  googleShape: function(map) {
    var longitudes_latitudes = _.zip.apply(null, this.get('coordinates'));
    // center always returns a lon,lat pair.
    // assume all Polygons are Rectangles, for now.
    return new google.maps.Rectangle({
      // LatLngBounds(sw?:LatLng, ne?:LatLng)
      bounds: new google.maps.LatLngBounds(
        new google.maps.LatLng(_.min(longitudes_latitudes[1]), _.min(longitudes_latitudes[0])),
        new google.maps.LatLng(_.max(longitudes_latitudes[1]), _.max(longitudes_latitudes[0]))
      ),
      clickable: false,
      map: map
      // strokeColor: '#FF0000',
      // strokeOpacity: 0.8,
      // strokeWeight: 2,
      // fillColor: '#FF0000',
      // fillOpacity: 0.35
    });
  }
}, {
  fromLatLngBounds: function(latLngBounds) {
    var sw = latLngBounds.getSouthWest();
    var ne = latLngBounds.getNorthEast();
    return new Geometries.Polygon({
      coordinates: [
        [sw.lng(), ne.lat()], // nw
        [ne.lng(), ne.lat()], // ne
        [ne.lng(), sw.lat()], // se
        [sw.lng(), sw.lat()], // sw
      ]
    });
  }
});

var Point = Backbone.Model.extend({
  // fields: type, coordinates
  initialize: function(opts) {
    this.set('type', 'Point');
  },
  toString: function() {
    var coordinates = this.get('coordinates');
    return [
      coordinates[0].toFixed(4),
      coordinates[1].toFixed(4)
    ].join(',');
  },
  focus: function(map) {
    var center = this.googleShape().getPosition();
    map.setCenter(center);
  },
  googleShape: function(map) {
    var coordinates = this.get('coordinates');
    return new google.maps.Marker({
      // GeoJSON is [longitude, latitude]
      position: new google.maps.LatLng(coordinates[1], coordinates[0]),
      clickable: false,
      map: map
    });
  }
}, {
  fromLatLng: function(latLng) {
    return new Geometries.Point({
      coordinates: [latLng.lng(), latLng.lat()]
    });
  }
});

var Geometries = {Polygon: Polygon, Point: Point};

var temporary_rectangle = null;
var mousedown_latLng = null;
var geocoder = new google.maps.Geocoder();
var dragging = false;

function parseLatLng(s) {
  var lat_lon_pair = s.split(/,/);
  return new google.maps.LatLng(lat_lon_pair[0], lat_lon_pair[1]);
}

$(function() {

  var features = new FeatureCollection();

  var $map = $('#map');

  var center = parseInt(localStorage.zoom || 8);

  var map = new google.maps.Map($map.get(0), {
    zoom: parseInt(localStorage.zoom || 8, 10),
    center: parseLatLng(localStorage.center || '41.8831,-87.6219'), // Millenium Park, Chicago, IL
    mapTypeId: google.maps.MapTypeId.ROADMAP
  });
  map.addListener('center_changed', function() {
    localStorage.center = map.getCenter().toUrlValue();
  })
  map.addListener('zoom_changed', function() {
    localStorage.zoom = map.getZoom();
  })
  map.setOptions(opts_interactive);

  // eavesdrop(map, google_map_events);

  var $features = $('table.features tbody');
  features.each(function(feature) {
    var feature_view = new FeatureView({model: feature, map: map});
    $features.append(feature_view.el);
  });

  // freeze the map on shift (which == 16)
  $(window).on('keydown', function(ev) {
    if (ev.which == 16) {
      map.setOptions(opts_frozen);
      $map.css({opacity: .7});
    }
  });
  $(window).on('keyup', function(ev) {
    if (ev.which == 16) {
      map.setOptions(opts_interactive);
      $map.css({opacity: .99});
    }
  });


  map.addListener('mousedown', function(ev) {
    mousedown_latLng = ev.latLng;
    if (down[16]) { // shift-down
      temporary_rectangle = new google.maps.Rectangle({
        bounds: new google.maps.LatLngBounds(ev.latLng, ev.latLng),
        clickable: false,
        map: map
        // strokeColor: '#FF0000',
        // strokeOpacity: 0.8,
        // strokeWeight: 2,
        // fillColor: '#FF0000',
        // fillOpacity: 0.35
      });
    }
    // ev.stop() does nothing
  });
  map.addListener('mousemove', function(ev) {
    $('#mouse_latitude').text(ev.latLng.lat().toFixed(8));
    $('#mouse_longitude').text(ev.latLng.lng().toFixed(8));

    if (temporary_rectangle && down[16]) { // shift-down
      var initial_bounds = new google.maps.LatLngBounds(mousedown_latLng, mousedown_latLng);
      temporary_rectangle.setBounds(initial_bounds.extend(ev.latLng));
      // "lat_lo,lng_lo,lat_hi,lng_hi"
    }
  });
  map.addListener('mouseup', function(ev) {
    var geometry = null;
    if (temporary_rectangle) {
      geometry = Polygon.fromLatLngBounds(temporary_rectangle.getBounds());
      temporary_rectangle.setMap(null);
      temporary_rectangle = null;
    }
    else if (!dragging) {
      geometry = Point.fromLatLng(ev.latLng);
    }

    if (geometry) {
      // cut off the day of the week, then capture until the timezone
      var label = new Date().toString().match(/^\w+ (.+) GMT/)[1];
      var feature = new Feature({
        geometry: geometry,
        properties: {label: label}
      });
      features.add(feature);

      var feature_view = new FeatureView({model: feature, map: map});
      $features.append(feature_view.el);
    }
  });
  map.addListener('dragstart', function() {dragging = true;});
  map.addListener('dragend', function() {dragging = false;});

  $('#clear').click(function() {
    features.reset();
    features.persist();
    $features.empty();
  });

  $('#me').click(function() {
    getPosition(function(err, position) {
      if (err) {
        console.error('Could not get user position: ' + err.toString());
      }
      else {
        var center = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
        map.setCenter(center);
        map.setZoom(16);
      }
    });
  });

  $('form').on('submit', function(ev, b) {
    var query = $(ev.target).find('input').val();
    ev.preventDefault();

    geocoder.geocode({address: query}, function(results, status) {
      if (status == google.maps.GeocoderStatus.OK) {
        var result = results[0];
        console.log('Search found', result);

        // geometry will be a box, if possible, otherwise just a point.
        var geometry = null;
        if (result.geometry.bounds) {
          geometry = Polygon.fromLatLngBounds(result.geometry.bounds);
        }
        else {
          geometry = Point.fromLatLng(result.geometry.location);
        }

        var feature = new Feature({
          geometry: geometry,
          properties: {label: result.formatted_address}
        });

        features.add(feature);
        var feature_view = new FeatureView({model: feature, map: map});
        $features.append(feature_view.el);
        geometry.focus(map);

        $('#search_results').html(result.formatted_address);
      }
      else {
        $('#search_results').html('Geocoder failed. ' + status.toString());
      }
    });
  });

});
</script>

<body>
  <div class="map-container">
    <div id="map"></div>
  </div>

  <div class="control" style="width: 230px;">
    <button id="me" style="margin: 0 0 10px 0">Geolocate me</button>

    <h3>Mouse Coordinates</h3>
    <table>
      <tr>
        <td>Latitude</td>
        <td id="mouse_latitude"></td>
      </tr>
      <tr>
        <td>Longitude</td>
        <td id="mouse_longitude"></td>
      </tr>
    </table>

    <h3>Search</h3>
    <form>
      <input name="query" />
      <button type="submit">Search</button>
    </form>
    <p id="search_results"></p>
  </div>

  <div class="control">
    <p>Hold <code>shift</code> to draw on the map.</p>
    <h3>Features</h3>
    <table class="features">
      <tbody></tbody>
    </table>
    <p><code>shift</code>+click to delete individual features</p>
    <button id="clear" style="margin: 10px 0">Clear all features</button>
  </div>

  <div style="clear: both">&nbsp;</div>

</body>
